\chapter{Basics}\label{sec:basics}

\section{cparser / libfirm}
Compilers are now written for half a century. Over the time a new structure has evolved. The compiler is split into two parts. The first part is called \textit{front end} and handles everything related to the language specific parts. The second part is called \textit{back end} and handles the translation into something like assembler or java bytecode. As an example, cparser is handling the c specific tasks. For the generation of the hardware instructions $\libFIRM$ is used.
The interaction between front end and back end is handled through a abstract data structure.
Before the abstract data structure is translated into hardware code, analysis and optimizations can take place. 
The data structure of the back end is build out of a graph with blocks.
A graph consists of nodes. Every node has a operands, and is representing a operation. In the rest of  Additionally a node is located in a block. A node is executed when all of its operands are done with execution. If there are no operands, the node is executed when the block is executed.
%FIXME reference to a better describing paper or smth.
A other software that does the same thing is \textit{clang}, where the back end is handled by llvm.


\subsection{Number representation}
So called \textit{modes} are used in libfirm to represent data words where operations are performed on. Such a mode has a length. A mode also has a type, the interesting types for us are the number style types. Which are integer and float. The most interesting for us are the integer-mode, since these are the types where we are performing our analysis on.

\begin{figure}
	\centering
	\begin{tabular}{c | c c c c c c c c c}
		value & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 \\
		\hline
		5     & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 1 \\
		-2    & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 0 \\
	\end{tabular}
	\caption{Number representation}
	\label{fig:numbers}
\end{figure}

Those integer-modes can be signed or unsigned. The length of the mode defines the maximum number. If it is signed, then it also defines the minimum number.Otherwise the minimum is just null. The sign is encoded using two's complement. As an example, in \autoref{fig:numbers} two numbers are displayed with its hardware representation.

The term \textit{mode} here is used to describe integer-modes for the rest of this text.

\section{Lattice}
A lattice is a algebra structure. There are the following rules for the them:
\begin{itemize}
	\item Finite number of elements
	\item $\vee: V \times V \rightarrow V$ will return the smallest element, that is bigger or equal than the two operands
	\item $\wedge: V \times V \rightarrow V$ will return the biggest element, that is smaller or equal than the two operands
	\item $\forall a,b \in V : \exists a \vee b \text{ AND } a \wedge b$
	\item $\forall u,v \in V : u \vee ( u \wedge v) = v \text{ AND } u \wedge ( u \vee v ) = v$
\end{itemize}

The element, which is the smallest from all elements, is called $\bot$. The biggest of all is called $\top$.

A lattice can also be made visible in a Hesse diagram, which you can see in \autoref{fig:lattice}
%idea of lattices
%moving in lattecis

\section{Fixed point iteration}

Fixed point iteration is a method for finding a fixed point, while iterating over a function. \newline
The function we use for iterating is called f, and is defined as $f: D \rightarrow D$. F is continues. We call $x \in D$ a fixed point if $f(x)=x$.

\paragraph{fixed points in compiler analysis}
We can transform and use the fixed point iteration to be working on a graph G. Each node has a number and a element from the lattice. In the beginning the element is $\bot$. We call the number of the node \textit{id}. The lattice element is called \textit{v}.
The set $D$ consists of elements of the form $\{id, v\}$. Where we can say that $|D| = |G|$, and every node from G is part of D.
The function f then calculates for every node, if a better v can be found. If there is one, then a new tuple $\{id, v\}$ with the better value will replace the old tuple in D.
If we now hit the situation where $f(x) = x$, then we know that we have found a fixed point, which is the best correct solution we could find.