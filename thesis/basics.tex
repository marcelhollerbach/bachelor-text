\chapter{Basics}\label{sec:basics}

\section{cparser / libfirm}
Modern compilers are now developed for half a century. Over the time a new structure has evolved. Compilers are split into two parts. The first part is called \textit{front end} and handles everything related to the language specific parts. The second part is called \textit{back end} and handles the translation into something like assembler or java bytecode. As an example, cparser is handling the c specific tasks. For the generation of the hardware instructions $\libFIRM$ is used.

\paragraph{Control flow graph in \libFIRM} The interaction between the front and back end is based on a data structure called control flow graph (CFG). A CFG is a directed graph. The relation from a node $A$ to a node $B$ can be interpreted as node $A$ having node $B$ as a operand.
CFGs are also the base structure for analyzing the control flow of a software. Such a analysis is called control flow analysis.

In $\libFIRM$ the nodes of the CFG can have different types: control flow, arithmetical operations, memory handing, constant expressing. A node is additionally placed in a block. A node is executed if all its operands have been executed. Or, if there are no operands, when its block is executed.
%FIXME reference to a better describing paper or smth. 
Another software that does the same thing is \textit{clang}, where the back end is handled by llvm.
A more in detail explanation can be found in TODO TODO.

\paragraph{interaction from front to back end}

\begin{figure}
	\centering
	\begin{lstlisting}[frame=single]
	#include <stdlib.h>
	#include <stdio.h>
	
	int main(int argc, char const *argv[]) {
	  printf("Hello Firm!");
	  return 0;
	}
	\end{lstlisting} 
	\caption{Sample source code}
	\label{code:workflow:example}
\end{figure}

As mentioned earlier, $\libFIRM$ users are building up a CFG using \libFIRM s API.
Now let us take cparser to see a example how the front end and the backend are working together. We want to compile the program code from \ref{code:workflow:example}.  \newline
First of all the front end will parse the given source code. The parsed code then will be stuffed into a abstract syntax tree (AST). The representation in the abstract syntax tree will encode the syntactical informations from the software. Informations like curly brackets will not be needed anymore. \newline
After that the AST will be transformed into a CFG. \newline
At this point the front end handed the informations for binary creation to the back end. However, the front end can now tell the back end to perform optimizations on the information. In terms of C this is often controlled with the -O{1,2,3} flags. \newline
At the last stage the back end is told to output a binary.

\subsection{Number representation}
So called \textit{modes} are used in libfirm to represent data words where operations are performed on. Such a mode has a length. A mode also has a type, the interesting types for us are the number style types. Which are integer and float. The most interesting for us are the integer-mode, since these are the types where we are performing our analysis on.

\begin{figure}
	\centering
	\begin{tabular}{c | c c c c c c c c c}
		value & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 \\
		\hline
		5     & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 1 \\
		-2    & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 0 \\
	\end{tabular}
	\caption{Number representation}
	\label{fig:numbers}
\end{figure}

Those integer-modes can be signed or unsigned. The length of the mode defines the maximum number. If it is signed, then it also defines the minimum number.Otherwise the minimum is just null. The sign is encoded using two's complement. As an example, in \autoref{fig:numbers} two numbers are displayed with its hardware representation.

The term \textit{mode} here is used to describe integer-modes for the rest of this text.

\section{Lattice}
A lattice is a algebra structure. There are the following rules for the them:
\begin{itemize}
	\item Finite number of elements
	\item $\vee: V \times V \rightarrow V$ will return the smallest element, that is bigger or equal than the two operands
	\item $\wedge: V \times V \rightarrow V$ will return the biggest element, that is smaller or equal than the two operands
	\item $\forall a,b \in V : \exists a \vee b \text{ AND } a \wedge b$
	\item $\forall u,v \in V : u \vee ( u \wedge v) = v \text{ AND } u \wedge ( u \vee v ) = v$
\end{itemize}

The element, which is the smallest from all elements, is called $\bot$. The biggest of all is called $\top$.

A lattice can also be made visible in a Hesse diagram, which you can see in \autoref{fig:lattice}
%idea of lattices
%moving in lattecis

\section{Fixed point iteration}

Fixed point iteration is a method for finding a fixed point, while iterating over a function. \newline
The function we use for iterating is called f, and is defined as $f: D \rightarrow D$. F is continues. We call $x \in D$ a fixed point if $f(x)=x$.

\paragraph{fixed points in compiler analysis}
We can transform and use the fixed point iteration to be working on a graph G. Each node has a number and a element from the lattice. In the beginning the element is $\bot$. We call the number of the node \textit{id}. The lattice element is called \textit{v}.
The set $D$ consists of elements of the form $\{id, v\}$. Where we can say that $|D| = |G|$, and every node from G is part of D.
The function f then calculates for every node, if a better v can be found. If there is one, then a new tuple $\{id, v\}$ with the better value will replace the old tuple in D.
If we now hit the situation where $f(x) = x$, then we know that we have found a fixed point, which is the best correct solution we could find.